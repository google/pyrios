// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pyrios

import (
	"crypto/rand"
	"crypto/sha1"
	"math/big"
	"strings"

	"github.com/golang/glog"
)

// NewSchnorrProof proves knowledge of a secret exponent in a cyclic group defined
// by an ElGamal public key.
func NewSchnorrProof(secret *big.Int, publicKey *Key) (*SchnorrProof, error) {
	w, err := rand.Int(rand.Reader, publicKey.ExponentPrime)
	if err != nil {
		return nil, err
	}

	// The commitment is g^w, and the challenge for the NIZKPOK is
	// generated by sha1(string(g^w)).
	com := new(big.Int).Exp(publicKey.Generator, w, publicKey.Prime)
	hash := sha1.Sum([]byte(com.String()))

	chall := new(big.Int).SetBytes(hash[:])

	resp := new(big.Int).Mul(secret, chall)
	resp.Mod(resp, publicKey.ExponentPrime)
	resp.Add(resp, w)
	resp.Mod(resp, publicKey.ExponentPrime)

	return &SchnorrProof{com, chall, resp}, nil
}

// NewPartialDecryptionProof produces a proof of knowledge of a value x for
// a DDH tuple (g, g^x, g^R, g^xR).  g^R is the tallied ciphertext alpha value,
// g^xR is the partial decryption, and g^x is the public key of the trustee.
func NewPartialDecryptionProof(ciphertext *Ciphertext, decFactor *big.Int, secret *big.Int, publicKey *Key) (*ZKProof, error) {
	// Choose a random value w as the first message.
	w, err := rand.Int(rand.Reader, publicKey.ExponentPrime)
	if err != nil {
		return nil, err
	}

	// Commit to w with A = g^w, B = alpha^w.
	com := &Commit{
		A: new(big.Int).Exp(publicKey.Generator, w, publicKey.Prime),
		B: new(big.Int).Exp(ciphertext.Alpha, w, publicKey.Prime),
	}

	// Compute the challenge using SHA1
	stringToHash := com.A.String() + "," + com.B.String()
	hashedChall := sha1.Sum([]byte(stringToHash))
	chall := new(big.Int).SetBytes(hashedChall[:])

	// response = w + challenge * secret
	resp := new(big.Int).Mul(chall, secret)
	resp.Add(resp, w)
	resp.Mod(resp, publicKey.ExponentPrime)
	return &ZKProof{chall, com, resp}, nil
}

// CreateFakeProof simulates proof creation for a value that's not really encrypted.
// It does this by taking advantage of the degrees of freedom inherent in the NIZKPOK
// for a single value. The only kind of NIZK proof that can be trusted in this system is
// the DisjunctiveZKProof, which is constructed so that exactly one of the values must
// be the encrypted value, and all the other proofs are simulated. And, of course, any
// proof that computes its challenge directly with a hash can be trusted.
func (zkproof *DisjunctiveZKProof) CreateFakeProof(index int64, fakeAnswer int64, c *Ciphertext, pk *Key) error {
	// Choose the challenge and the response at random, and compute the commitment to match.
	chall, err := rand.Int(rand.Reader, pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random challenge")
		return err
	}

	resp, err := rand.Int(rand.Reader, pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random response")
		return err
	}

	// A = (c.Alpha^chall)^{-1} * pk.Generator^resp
	A := new(big.Int).Exp(pk.Generator, resp, pk.Prime)
	temp := new(big.Int).Exp(c.Alpha, chall, pk.Prime)
	temp.ModInverse(temp, pk.Prime)
	A.Mul(A, temp)
	A.Mod(A, pk.Prime)

	// B = pk.PublicValue^resp * (c.Beta/pk.Generator^fakeAnswer)^{-chall}
	B := new(big.Int).Exp(pk.PublicValue, resp, pk.Prime)
	fake := big.NewInt(fakeAnswer)
	temp.Exp(pk.Generator, fake, pk.Prime)
	temp.ModInverse(temp, pk.Prime)
	temp.Mul(temp, c.Beta)
	temp.Mod(temp, pk.Prime)
	temp.Exp(temp, chall, pk.Prime)
	temp.ModInverse(temp, pk.Prime)
	B.Mul(B, temp)
	B.Mod(B, pk.Prime)

	(*zkproof)[index] = &ZKProof{chall, &Commit{A, B}, resp}
	return nil
}

// CreateRealProof computes a real NIZKPOK for the answer, which must be the
// value encrypted in the supplied ciphertext. Before this function can be
// called, all the simulated proofs in the DisjunctiveZKProof must be created,
// so that all the commitments are known and can be used to compute the
// challenge value for this proof.
func (zkproof *DisjunctiveZKProof) CreateRealProof(index int64, c *Ciphertext, r *big.Int, pk *Key) error {
	w, err := rand.Int(rand.Reader, pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random value")
		return err
	}

	// Computing the full challenge requires all the commitments, including this one.
	A := new(big.Int).Exp(pk.Generator, w, pk.Prime)
	B := new(big.Int).Exp(pk.PublicValue, w, pk.Prime)
	(*zkproof)[index] = &ZKProof{Commitment: &Commit{A, B}}

	challSum := big.NewInt(0)
	var commitVals []string
	for i, p := range *zkproof {
		// Accumulate the homomorphic product to sum the other challenge values.
		if int64(i) != index {
			challSum.Add(challSum, p.Challenge)
		}

		commitVals = append(commitVals, p.Commitment.A.String())
		commitVals = append(commitVals, p.Commitment.B.String())
	}

	challSum.Mod(challSum, pk.ExponentPrime)

	// Create a well-formed challenge.
	stringToHash := strings.Join(commitVals, ",")
	hashedCommits := sha1.Sum([]byte(stringToHash))

	hashedChall := new(big.Int).SetBytes(hashedCommits[:])

	// challenge = sha1(A0,B0,...,An,Bn) - sum(all other challenges in the proof)
	chall := new(big.Int).Sub(hashedChall, challSum)
	chall.Mod(chall, pk.ExponentPrime)

	// response = w + chall * r
	resp := new(big.Int).Mul(chall, r)
	resp.Add(resp, w)
	resp.Mod(resp, pk.ExponentPrime)

	p := (*zkproof)[index]
	p.Challenge = chall
	p.Response = resp

	return nil
}

// SplitKey performs an (n,n)-secret sharing of privateKey over addition mod
// publicKey.ExponentPrime.
func SplitKey(privateKey *big.Int, publicKey *Key, n int) ([]*Trustee, []*big.Int, error) {
	// Choose n-1 random private keys and compute the nth as privateKey -
	// (key_1 + key_2 + ... + key_{n-1}). This computation must be
	// performed in the exponent group of g, which is
	// Z_{Key.ExponentPrime}.
	trustees := make([]*Trustee, n)
	keys := make([]*big.Int, n)
	sum := big.NewInt(0)
	var err error
	for i := 0; i < n-1; i++ {
		keys[i], err = rand.Int(rand.Reader, publicKey.ExponentPrime)
		if err != nil {
			return nil, nil, err
		}

		pok, err := NewSchnorrProof(keys[i], publicKey)
		if err != nil {
			return nil, nil, err
		}

		tpk := &Key{
			Generator:     new(big.Int).Set(publicKey.Generator),
			Prime:         new(big.Int).Set(publicKey.Prime),
			ExponentPrime: new(big.Int).Set(publicKey.ExponentPrime),
			PublicValue:   new(big.Int).Exp(publicKey.Generator, keys[i], publicKey.Prime),
		}

		trustees[i] = &Trustee{PoK: pok, PublicKey: tpk}
		sum.Add(sum, keys[i])
		sum.Mod(sum, publicKey.ExponentPrime)
	}

	// The choice of random private keys in the loop fully determines the
	// final key.
	keys[n-1] = new(big.Int).Sub(privateKey, sum)
	keys[n-1].Mod(keys[n-1], publicKey.ExponentPrime)
	npok, err := NewSchnorrProof(keys[n-1], publicKey)
	if err != nil {
		return nil, nil, err
	}

	ntpk := &Key{
		Generator:     new(big.Int).Set(publicKey.Generator),
		Prime:         new(big.Int).Set(publicKey.Prime),
		ExponentPrime: new(big.Int).Set(publicKey.ExponentPrime),
		PublicValue:   new(big.Int).Exp(publicKey.Generator, keys[n-1], publicKey.Prime),
	}

	trustees[n-1] = &Trustee{PoK: npok, PublicKey: ntpk}
	return trustees, keys, nil
}
